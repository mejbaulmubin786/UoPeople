
<!-- saved from url=(0073)https://www.cs.auckland.ac.nz/software/AlgAnim/binsort.html#bin_sort_anim -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Data Structures and Algorithms: Bin Sort</title>

<meta name="description" content="Data Structures and Algorithms Course Notes,
PLDS210 University of Western Australia">
<meta name="keywords" content="data structures,algorithms,abstract data types,
sorting, bin sort">
</head>
<body bgcolor="#ffffff" data-new-gr-c-s-check-loaded="14.1077.0" data-gr-ext-installed="">
<table bgcolor="#00c0f0" width="100%" cellspacing="0" cellpadding="0">
<tbody><tr bgcolor="#00f0f0"><td align="right">
<font face="helvetica" size="+1"><i>Data Structures and Algorithms</i></font>
</td></tr>

<tr><td><font face="helvetica" size="+2"><b>7.4 Bin Sort</b></font>
</td></tr>
</tbody></table>
<p>
 
 Assume that
 </p><ol> 
 <li> the keys of the items that we wish to
 sort lie in a small fixed range and 
 </li><li> that there is
 only one item with each value of the key.
 </li></ol>
 Then we can sort with the following procedure:
 <ol>
 <li> Set up an array of "bins" - one for each value of the key -
 in order,
 </li><li> Examine each item and use the value of the key to place
 it in the appropriate bin.
 </li></ol>
 Now our collection is sorted and it only took <b>n</b>
 operations, so this is an <b>O(n)</b> operation.
 However, note that it will only work under very restricted
 conditions.
 <p>

</p><h4>Constraints on bin sort</h4>

To understand these restrictions,
let's be a little more precise about the specification of the
 problem and assume that there are <b>m</b> values of the
 key. To recover our sorted collection, we need to examine each
 bin.
 This adds a third step to the algorithm above,
<ol start="3">
<li> Examine each bin to see whether there's an item in it.
</li></ol>
which requires 
 <b>m</b> operations. So the algorithm's time becomes:
 <center>
 <b>T(n) = c<sub>1</sub>n + c<sub>2</sub>m</b>
 </center>
 and it is strictly <b>O(n + m)</b>.
 Now if <b>m &lt;= n</b>, this is clearly <b>O(n)</b>.
 However if <b>m &gt;&gt; n</b>, then it is <b>O(m)</b>.
 <p>
 For example, if we wish to sort 10<sup>4</sup> 32-bit integers,
 then <b>m</b> = 2<sup>32</sup> and we need 2<sup>32</sup> operations
 (and a rather large memory!).
 <br>
 For <b>n</b> = 10<sup>4</sup>:<br>
 </p><center>
<b>nlogn</b> ~ 10<sup>4</sup> x 13 ~ 2<sup>13</sup> x 2<sup>4</sup>
 ~ 2<sup>17</sup>
</center>
So quicksort or heapsort would clearly be preferred.
<p>
An implementation of bin sort might look like:
</p><p><font color="green">
</font></p><pre><font color="green">#define EMPTY	-1 /* Some convenient flag */
void bin_sort( int *a, int *bin, int n ) {
    int i;
    /* Pre-condition: for 0&lt;=i&lt;n : 0 &lt;= a[i] &lt; M */
    /* Mark all the bins empty */
    for(i=0;i&lt;M;i++) bin[i] = EMPTY;
    for(i=0;i&lt;n;i++)
        bin[ a[i] ] = a[i];
    }

main() {
    int a[N], bin[M];    /* for all i: 0 &lt;= a[i] &lt; M */
    .... /* Place data in a */
    bin_sort( a, bin, N );

</font></pre>
<p>
If there are duplicates, then each bin can be replaced by a linked list.
The third step then becomes:
</p><ol start="3">
<li>Link all the lists into one list. 
</li></ol>
We can add an item to a linked list in <b>O(1)</b> time.
There are <b>n</b> items requiring <b>O(n)</b> time.
Linking a list to another list simply involves making the
tail of one list point to the other, so it is <b>O(1)</b>. 
Linking <b>m</b> such lists obviously takes <b>O(m)</b> time,
so the algorithm is still <b>O(n+m)</b>.
<p>
In contrast to the other sorts, which sort <i>in place</i> and don't 
require additional memory,
bin sort requires additional memory for the bins and is a good example of
trading space for performance.
</p><p>
</p><center><table border="2">
<tbody><tr><td>
<center>Although memory tends to be cheap in modern processors - <br>
so that we would normally use memory rather profligately to
obtain performance,<br>
<font color="red">memory consumes power</font><br>
and in some circumstances, 
<i>eg</i> computers in space craft,<br>
power might be a higher constraint than performance.</center>
</td></tr>
</tbody></table></center>
<p>
Having highlighted this constraint, there is a version of 
bin sort which can sort in place:
<font color="green">
</font></p><pre><font color="green">#define EMPTY	-1 /* Some convenient flag */
void bin_sort( int *a, int n ) {
    int i;
    /* Pre-condition: for 0&lt;=i&lt;n : 0 &lt;= a[i] &lt; n */
    for(i=0;i&lt;n;i++)
	if ( a[i] != i )
            SWAP( a[i], a[a[i]] );
    }
</font></pre>
However, this assumes that there are <b>n</b> distinct keys
in the range 0 .. <b>n</b>-1.
In addition to this restriction, the SWAP operation is relatively
expensive, so that this version trades space for time.
<p>
The bin sorting strategy may appear rather limited,
but it can be generalised into a strategy known as
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/radixsort.html">Radix sorting</a>.


</p><p>
<a name="bin_sort_anim">
<table bgcolor="#00f0f0" width="100%"> 
<tbody><tr><td>
<font color="blue" face="helvetica">
<b>Bin Sort Animation</b><br>
This animation was written by Woi Ang.</font></td>
<td align="center">
  <table border="0">
  <tbody><tr><td>
    <applet codebase="Java/bin_sort" code="AlgAnimApp.class" width="200" height="35">
    <param name="filename" value="AlgThread.java">
    <param name="buttonname" value="Run Bin Sort Animation">
    <param name="algname" value="Bin Sort">
    </applet>
    </td>
  </tr>
</tbody></table>
</td>
<td><font face="helvetica">Please email comments to:<br>
<img src="./Data Structures and Algorithms_ Bin Sort_files/john_email.gif">
</font></td></tr>
</tbody></table>

</a></p><p><a name="bin_sort_anim">

<table cellpadding="5" width="100%" bgcolor="#00f0f0" cellspacing="4">
<tbody><tr><td width="50%">
Continue on to <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/radixsort.html">Radix sorting</a></td>
<td>Back to the <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/ds_ToC.html">Table of Contents</a>
</td></tr></tbody></table>
<small>
Â© <img src="./Data Structures and Algorithms_ Bin Sort_files/john_email.gif">, 1998
</small>


</a></p></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>