
<!-- saved from url=(0071)https://www.cs.auckland.ac.nz/software/AlgAnim/sorting.html#insert_anim -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Data Structures and Algorithms: Sorting</title>

<meta name="description" content="Data Structures and Algorithms Course Notes,
PLDS210 University of Western Australia">
<meta name="keywords" content="data structures,algorithms,abstract data types,
sorting, bubble sort, selection sort, insertion sort">
</head>
<body bgcolor="#ffffff" data-new-gr-c-s-check-loaded="14.1077.0" data-gr-ext-installed="">
<table bgcolor="#00c0f0" width="100%" cellspacing="0" cellpadding="0">
<tbody><tr bgcolor="#00f0f0"><td align="right">
<font face="helvetica" size="+1"><i>Data Structures and Algorithms</i></font>
</td></tr>

<tr><td><font face="helvetica" size="+2"><b>7 Sorting</b></font>
</td></tr>
</tbody></table>
<p>

Sorting is one of the most important operations performed
by computers.
In the days of magnetic tape storage before modern data-bases,
it was almost certainly the <i>most</i> common operation
performed by computers as most "database" updating was done
by sorting transactions and merging them with a master file.
It's still important for presentation of data extracted from
databases: most people prefer to get reports sorted into some
relevant order before wading through pages of data!

<a name="bubble"></a>
</p><h3>7.1 Bubble, Selection, Insertion Sorts</h3>
There are a large number of variations of one basic
strategy for sorting.
It's the same strategy that you use for sorting your
bridge hand. You pick up a card, 
start at the beginning of your hand and find the place
to insert the new card, insert it and move all the others
up one place.
<font color="green">
<pre>/* Insertion sort for integers */

void insertion( int a[], int n ) {
/* Pre-condition: a contains n items to be sorted */
    int i, j, v;
    /* Initially, the first item is considered 'sorted' */
    /* i divides a into a sorted region, x&lt;i, and an
       unsorted one, x &gt;= i */
    for(i=1;i&lt;n;i++) {
        /* Select the item at the beginning of the
           as yet unsorted section */
        v = a[i];
        /* Work backwards through the array, finding where v 
           should go */
        j = i;
        /* If this element is greater than v,
              move it up one */
        while ( a[j-1] &gt; v ) {
          a[j] = a[j-1]; j = j-1;
          if ( j &lt;= 0 ) break;
          }
        /* Stopped when a[j-1] &lt;= v, so put v at position j */
        a[j] = v;
        }
    }    
</pre></font>

<a name="insert_anim">
<table bgcolor="#00f0f0" width="100%"> 
<tbody><tr><td>
<font color="blue" face="helvetica">
<b>Insertion Sort Animation</b><br>
This animation was written by Woi Ang.</font></td>
<td align="center">
  <table border="0">
  <tbody><tr><td>
    <applet codebase="Java/ins_sort" code="AlgAnimApp.class" width="200" height="35">
    <param name="filename" value="AlgThread.java">
    <param name="buttonname" value="Run the Animation">
    <param name="algname" value="Insertion Sort">
    </applet>
    </td>
  </tr>
</tbody></table>
</td>
<td><font face="helvetica">Please email comments to:<br>
<img src="./Data Structures and Algorithms_ Sorting_files/john_email.gif">
</font></td></tr>
</tbody></table>
<p>
</p><h3>Bubble Sort</h3>

Another variant of this procedure, called bubble sort, is commonly taught:
<font color="green">
<pre>/* Bubble sort for integers */
#define SWAP(a,b)   { int t; t=a; a=b; b=t; }

void bubble( int a[], int n )
/* Pre-condition: a contains n items to be sorted */
    {
    int i, j;
    /* Make n passes through the array */
    for(i=0;i&lt;n;i++)
        {
        /* From the first element to the end
           of the unsorted section */
        for(j=1;j&lt;(n-i);j++)
           {
           /* If adjacent items are out of order, swap them */
           if( a[j-1]&gt;a[j] ) SWAP(a[j-1],a[j]);
           }
        }
    }    
</pre></font>

<h3>Analysis</h3>

Each of these algorithms requires <b><i>n</i></b>-1 passes:
each pass places one item in its correct place.
(The <b><i>n<sup>th</sup></i></b> is then in the correct place also.)
The <b><i>i<sup>th</sup></i></b> pass makes either <b><i>i</i></b>or 
<b><i>n - i</i></b> comparisons and moves.
So:
<blockquote>
<img src="./Data Structures and Algorithms_ Sorting_files/sumi.gif">
</blockquote>
or <b>O(<i>n</i><sup>2</sup>)</b> -
but we already know we can use heaps to get an
<b>O(<i>n</i> log<i>n</i>)</b>
algorithm.
Thus these algorithms are only suitable for small
problems where their simple code makes them faster than
the more complex code of the
<b>O(<i>n</i> log<i>n</i>)</b>
algorithm.
As a rule of thumb, expect to find an
<b>O(<i>n</i> log<i>n</i>)</b>
algorithm faster for <i>n</i>&gt;10 -
<i>but the exact value depends very much on individual machines!</i>.
</a><p><a name="insert_anim">
They can be used to squeeze a little bit more performance out
of fast sort algorithms - </a><a href="https://www.cs.auckland.ac.nz/software/AlgAnim/qsort_perf.html">see later</a>.

</p><p>
<table width="100%" bgcolor="#00c0f0">
<tbody><tr><td><h3>Key terms</h3></td></tr></tbody></table>
</p><dl>
<dt><font color="#fa0000"><b>Bubble, Insertion, Selection Sorts</b></font>
   </dt><dd>Simple sorting algorithms with <b><i>O(n<sup>2</sup>)</i></b>
      complexity - suitable for sorting small numbers of items only.
</dd></dl>

<p>

<table cellpadding="5" width="100%" bgcolor="#00f0f0" cellspacing="0">
<tbody><tr><td>
Continue on to <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/heapsort.html">Heap Sort</a><br>
Back to the <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/ds_ToC.html">Table of Contents</a>
</td></tr></tbody></table>
<small>
Â© <img src="./Data Structures and Algorithms_ Sorting_files/john_email.gif">, 1998
</small>


</p></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>