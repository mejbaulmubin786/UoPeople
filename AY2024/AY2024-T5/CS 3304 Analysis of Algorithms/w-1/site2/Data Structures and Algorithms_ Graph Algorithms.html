
<!-- saved from url=(0064)https://www.cs.auckland.ac.nz/software/AlgAnim/mst.html#mst_anim -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Data Structures and Algorithms: Graph Algorithms</title>

<meta name="description" content="Data Structures and Algorithms Course Notes,
PLDS210 University of Western Australia">
<meta name="keywords" content="data structures,algorithms,abstract data types,
graph algorithms, mininum spanning tree">
</head>
<body bgcolor="#ffffff" data-new-gr-c-s-check-loaded="14.1077.0" data-gr-ext-installed="">
<table bgcolor="#00c0f0" width="100%" cellspacing="0" cellpadding="0">
<tbody><tr bgcolor="#00f0f0"><td align="right">
<font face="helvetica" size="+1"><i>Data Structures and Algorithms</i></font>
</td></tr>

<tr><td><font face="helvetica" size="+2"><b>10 Graphs</b></font>
</td></tr>
</tbody></table>
<p>


</p><h3>10.1 Minimum Spanning Trees</h3>

<h4>Greedy Algorithms</h4>

Many algorithms can be formulated as a finite series of guesses,
<i>eg</i> in the Travelling Salesman Problem,
we try (guess) each possible tour in turn and determine
its cost.
When we have tried them <strong>all</strong>,
 we know which one is the optimum (least cost) one.
However, we must try them all before we can be certain that we
know which is the optimum one, 
leading to an <b><i>O(n!)</i></b> algorithm.
<p>
Intuitive strategies, such as
building up the salesman's tour by adding the city which is closest to
the current city, can readily be shown to produce sub-optimal tours.
As another example, an experienced chess player will not take an
opponent's pawn with his queen - because that move produced the
maximal gain, the capture of a piece - if his opponent is guarding that
pawn with another pawn. In such games, you must look at <i>all</i> the
moves ahead to ensure that the one you choose is in fact the optimal
one. All chess players know that short-sighted strategies are good 
recipes for disaster!
</p><p>
There is a class of algorithms, the <i>greedy algorithms</i>,
in which we can find a solution by using only knowledge available at
the time the next choice (or guess) must be made.
The problem of finding the Minimum Spanning Tree is a good example
of this class.</p><p>
</p><h4>The Minimum Spanning Tree Problem</h4>
Suppose we have a group of islands that we wish to link with bridges
so that it is possible to travel from one island to any other in the group.
Further suppose that (as usual) our government wishes to spend the 
absolute minimum amount on this project (because other factors like the
cost of using, maintaining, etc, these bridges will probably be the responsibility
of some future government <img src="./Data Structures and Algorithms_ Graph Algorithms_files/smiley.gif" alt="Unable to display image" border="0" align="middle">).
 The engineers are able to
produce a cost for a bridge linking each possible pair of islands. 
The set of bridges which will enable one to travel from any island to any other
at minimum capital cost to the government is the <i>minimum spanning tree</i>.<p>
We will need some definitions first:
</p><h4>Graphs</h4><p>
A graph is a set of <i>vertices</i> and <i>edges</i> which connect them.
We write:</p><p>
</p><center><b> G = (V,E)</b></center>
<p>
where <b>V</b> is the set of vertices and
 the set of edges,</p><p>
</p><center><strong>E = { (v<sub>i</sub>,v<sub>j</sub>) }</strong></center>
where <b>v<sub>i</sub></b> and
<b>v<sub>j</sub></b> are in <b>V</b>.
<h4>Paths</h4>
A <i>path</i>, <b>p</b>, of length, <b>k</b>, through a 
graph is a sequence of connected vertices:<p>
</p><center><b>p = &lt;v<sub>0</sub>,v<sub>1</sub>,...,v<sub>k</sub>&gt;</b></center>
where, for all <b>i</b> in (0,<b>k</b>-1:<p>
</p><center>
<b>(v<sub>i</sub>,v<sub>i+1</sub>)</b> is in <b>E</b>.</center>
<p>
</p><h4>Cycles</h4><p>
</p><p>
A graph contains no <i>cycles</i> if there is no path
of non-zero length through the
graph,
<b>p = &lt;v<sub>0</sub>,v<sub>1</sub>,...,v<sub>k</sub>&gt;</b>
such that <b>v<sub>0</sub> = v<sub>k</sub></b>.
</p><h4>Spanning Trees</h4>
<p>
A <i>spanning tree</i> of a graph, G, is a set of
<b>|V|</b>-1 edges that connect all vertices of the
graph.
</p><h4>Minimum Spanning Tree</h4>
In general, it is possible to construct multiple spanning trees for a
graph, <b>G</b>.
If a cost, <b>c<sub>ij</sub></b>, is associated with each edge,
<b>e<sub>ij</sub> = (v<sub>i</sub>,v<sub>j</sub>)</b>,
then the minimum spanning tree is the set of edges, 
<b>E<sub>span</sub></b>, forming a spanning tree,
such that:
<p></p><center>
<b>C = sum( c<sub>ij</sub></b> | all <b>e<sub>ij</sub></b> in <b>E<sub>span</sub> </b>)
</center><p>
is a minimum.
</p><h4>Kruskal's Algorithm</h4>
This algorithm creates a <i>forest</i> of trees.
Initially the forest consists of <b>n</b> single node trees
(and no edges).
At each step, we add one (the cheapest one) edge so
that it joins two trees together.
If it were to form a cycle, it would simply link
two nodes that were already part of a single connected tree,
so that this edge would not be needed.
<p>
The basic algorithm looks like this:
<font color="green">
</font></p><pre><font color="green">Forest MinimumSpanningTree( Graph g, int n, double **costs ) {
   Forest T;
   Queue q;
   Edge e;
   T = ConsForest( g );
   q = ConsEdgeQueue( g, costs );
   for(i=0;i&lt;(n-1);i++) {
       do {
          e = ExtractCheapestEdge( q );
       } while ( Cycle( e, T ) );
       AddEdge( T, e );
   }
   return T;
}
</font></pre>
The steps are:
<ol>
<li> Construct a forest - with each node in a
separate tree.
</li><li> Place the edges in a priority queue.
</li><li> Until we've added <b>n</b>-1 edges,
  <ol>
   <li> Continue extracting the cheapest edge from the queue, <br>
     until we find one that does not form a cycle,
   </li><li> Add it to the forest.
   Adding it to the forest will join two trees together.
  </li></ol>
</li></ol>
Every step joins two trees in the forest together,
so that, at the end, 
only one tree will remain in T.
<p>
We can use a heap for the priority queue.
The trick here is to detect cycles.
For this, we need a
<i>union-find</i> structure.

</p><h4>Union-find structure</h4>

To understand the union-find structure, we need to look at
a <i>partition</i> of a set.

<h4>Partitions</h4>

A partitions is a set of sets of elements of a set.
<ul>
<li>Every element of the set belong to one of the sets in the
partition.
</li><li>No element of the set belong to more than one of the sub-sets.
</li></ul>
or<ul>
<li> Every element of a set belongs to one <i>and only one</i>
of the sets of a partition.
</li></ul>
<p>
The forest of trees is a partition of the original set of nodes.
Initially all the sub-sets have exactly one node in them.
As the algorithm progresses, we form a union of two of the trees
(sub-sets), until eventually the partition has only one sub-set 
containing all the nodes.
</p><p>
A partition of a set may be thought of as a set of 
<i>equivalence classes</i>.
Each sub-set of the partition contains a set of equivalent
elements (the nodes connected as one of the trees of the
forest). 
This notion is the key to the cycle detection algorithm.
For each sub-set, we denote one element as the 
<i>representative</i> of that sub-set or equivalence class.
Each element in the sub-set is, somehow, equivalent and
represented by the nominated representative.
</p><p>
As we add elements to a tree,
we arrange that all the elements point to their representative.
As we form a union of two sets, 
we simply set the representative of one of the sets
to point to any element of the other set.
</p><p>
So the test for a cycle reduces to:
for the two nodes at the ends of the candidate edge,
find their representatives.
If the two representatives are the same, the two
nodes are already in a connected tree and adding this
edge would form a cycle.
The search for the representative simply follows a chain of
links.
</p><p>
Each node will need a representative pointer.
Initially, each node is its own representative, 
so the pointer is set to NULL.
As the initial pairs of nodes are joined to form a tree,
the representative pointer of one of the nodes is made to point
to the other, which becomes the representative of the tree.
As trees are joined, the representative pointer of the
representative of one 
of them is set to point to any element of the
other. (Obviously, representative searches will be 
somewhat faster if one of the representatives is made to
point directly to the other.)
</p><p>
</p><center>
<table border="1" width="70%"><tbody><tr><td><center>
Equivalence classes also play an important role in the<br>
<a href="https://www.cs.auckland.ac.nz/Year1/CLP110/verify.html" target="ObjectsFirst">verification</a> of software.</center></td></tr>
</tbody></table></center>
<p>
Select diagrams of
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/krusk.html" target="Kruskal&#39;s algorithm">Kruskal's algorithm</a>
in operation.
</p><h4>Greedy operation</h4>
At no stage did we try to look ahead more than one
edge - we simply chose the best one at any stage.
Naturally, in some situations, this myopic view would lead
to disaster!
The simplistic approach
often makes it difficult to prove that a greedy 
algorithm leads to the <i>optimal</i> solution.
proof by contradiction is a common proof
technique used: we demonstrate that if we didn't make
the greedy choice now, a non-optimal solution would result.
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/greedy_proof.html">Proving the MST algorithm</a><br>
is, happily, one of the simpler proofs by contradiction!

<h4>Data structures for graphs</h4>

You should note that we have discussed graphs in an abstract
way: specifying that they contain nodes and edges and using
operations like <tt>AddEdge</tt>, <tt>Cycle</tt>, <i>etc</i>.
This enables us to define an abstract data type <i>without</i>
considering implementation details, such as how we will store the
attributes of a graph! 
This means that a complete solution to, for example, the MST
problem can be specified before we've even decided how to store
the graph in the computer.
However, representation issues can't be deferred forever,
so we need to examine ways of
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/graph_rep.html">representing graphs</a> in a machine.
As before, the performance of the algorithm will be determined
by the data structure chosen.
<p>


</p><p>
<a name="mst_anim">
<table bgcolor="#00f0f0" width="100%"> 
<tbody><tr><td>
<font color="blue" face="helvetica">
<b>Minimum Spanning Tree Animation</b><br>
This animation was written by Mervyn Ng.</font></td>
<td align="center">
  <table border="0">
  <tbody><tr><td>
    <applet codebase="Java/mst" code="AlgAnimApp.class" width="200" height="35">
    <param name="filename" value="GraphMST.java">
    <param name="buttonname" value="Run the Animation">
    <param name="algname" value="MST Algorithm">
    <param name="algfile" value="graph.mst">
    </applet>
    </td>
  </tr>
</tbody></table>
</td>
<td><font face="helvetica">Please email comments to:<br>
<img src="./Data Structures and Algorithms_ Graph Algorithms_files/john_email.gif">
</font></td></tr>
</tbody></table>

</a></p><p><a name="mst_anim">
<table width="100%" bgcolor="#00c0f0">
<tbody><tr><td><h3>Key terms</h3></td></tr></tbody></table>
</a></p><dl><a name="mst_anim">
<dt><font color="#fa0000"><b>Greedy algorithms</b></font>
   </dt><dd>Algorithms which solve a problem by making the next step
     based on local knowledge alone - without looking ahead to
     determine whether the next step is the optimal one.
</dd><dt><font color="#fa0000"><b>Equivalence Classes</b></font>
   </dt><dd>The set of equivalence classes of a set is a 
     <font color="#fa0000"><b>partition</b></font> of a set
     such that all the elements in each subset (or 
      <font color="#fa0000"><b>equivalence class</b></font>)
      is related to every other element in the subset by an
      <font color="#fa0000"><b>equivalence relation</b></font>.
</dd><dt><font color="#fa0000"><b>Union Find Structure</b></font>
   </dt><dd>A structure which enables us to determine whether two sets
       are in fact the same set or not.
</dd><dt><font color="#fa0000"><b>Kruskal's Algorithm</b></font>
   </dt><dd>One of the two algorithms commonly used for finding a 
   minimum spanning tree - the other is <font color="#fa0000"><b>
    Prim's algorithm</b></font>.
</dd></a></dl><a name="mst_anim">

<p>

<table cellpadding="5" width="100%" bgcolor="#00f0f0" cellspacing="4">
<tbody><tr><td width="33%">
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/greedy_proof.html">Proving the MST algorithm</a></td>
<td width="33%"><a href="https://www.cs.auckland.ac.nz/software/AlgAnim/graph_rep.html">Graph Representations</a></td>
<td>Back to the <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/ds_ToC.html">Table of Contents</a>
</td></tr></tbody></table>
<small>
Â© <img src="./Data Structures and Algorithms_ Graph Algorithms_files/john_email.gif">, 1998
</small>


</p></a></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>