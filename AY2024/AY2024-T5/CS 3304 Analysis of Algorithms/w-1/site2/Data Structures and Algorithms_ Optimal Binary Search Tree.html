
<!-- saved from url=(0072)https://www.cs.auckland.ac.nz/software/AlgAnim/opt_bin.html#opt_bin_anim -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Data Structures and Algorithms: Optimal Binary Search Tree</title>

<meta name="description" content="Data Structures and Algorithms Course Notes,
PLDS210 University of Western Australia">
<meta name="keywords" content="data structures, algorithms,
binary search tree,
optimal binary search tree, dynamic algorithms, animation">
</head>
<body bgcolor="#ffffff" data-new-gr-c-s-check-loaded="14.1077.0" data-gr-ext-installed="">
<table bgcolor="#00c0f0" width="100%" cellspacing="0" cellpadding="0">
<tbody><tr bgcolor="#00f0f0"><td align="right">
<font face="helvetica" size="+1"><i>Data Structures and Algorithms</i></font>
</td></tr>

<tr><td><font face="helvetica" size="+2"><b>9.3 Optimal Binary Search Trees</b></font>
</td></tr>
</tbody></table>
<p>

Up to this point, we have assumed that an <i>optimal search tree</i>
is one in which the probability of occurrence of all keys is
equal (or is unknown, in which case we assume it to be equal).
Thus we concentrated on <i>balancing</i> the tree so as to make
the cost of finding any key <i>at most</i> <b>log n</b>.
</p><p>
However, consider a dictionary of words used by a spelling checker
for English language documents.
It will be searched many more times
for 'a', 'the', 'and', <i>etc</i> than for the thousands of
uncommon words which are in the dictionary just in case someone
happens to use one of them. 
Such a dictionary needs to be large: the average educated person
has a vocabulary of 30 000 words, so it needs ~100 000 words in 
it to be effective. It is also reasonably easy to produce a
table of the frequency of occurrence of words: words are simply
counted in any suitable collection of documents considered to be
representative of those for which the spelling checker will be used.

A balanced binary tree is likely to end up with a word such as
'miasma' at its root, guaranteeing that in 99.99+% of searches,
at least one comparison is wasted!
</p><p>
If key, <b>k</b>, has relative frequency, <b>r<sub>k</sub></b>,
then in an <b>optimal tree</b>, 
</p><center><b>sum(d<sub>k</sub>r<sub>k</sub>)</b>
</center>
where <b>d<sub>k</sub></b> is the distance of the key, <b>k</b>,
from the root (<i>ie</i> the number of comparisons which must be
made before <b>k</b> is found), is minimised.
<p>
We make use of the property:
</p><blockquote>
<h4>Lemma</h4>
Sub-trees of optimal trees are themselves optimal trees.
<h4>Proof</h4>
If a sub-tree of a search tree is not an optimal tree, 
then a better search tree will be produced if the sub-tree
is replaced by an optimal tree.
</blockquote>
Thus the problem is to determine which key should be placed
at the root of the tree.
Then the process can be repeated for the left- and right-sub-trees.
However, a divide-and-conquer approach would choose each
key as a candidate root and repeat the process for each 
sub-tree.
Since there are <b>n</b> choices for the root and
2<b>O(n)</b> choices for roots of the two sub-trees,
this leads to an <b>O(n<sup>n</sup></b>) algorithm.
<p>
An efficient algorithm can be generated by the <b>dynamic</b>
approach.
We calculate the <b>O(n)</b> best trees consisting of just
two elements (the neighbours in the sorted list of keys).
<table>
<tbody><tr><td><img src="./Data Structures and Algorithms_ Optimal Binary Search Tree_files/optbin_a.gif"></td>
<td>In the figure, there are two possible
arrangements for the tree containing <b>F</b>
and <b>G</b>.<p>
The cost for (a) is
</p><center> 5.1 + 7.2 = 19</center>
and for (b)
<center> 7.1 + 5.2 = 17</center>
<p>
Thus (b) is the optimum tree and its
cost is saved as c(f,g).
We also store <b>g</b> as the root of the
best f-g sub-tree in best(f,g).
</p><p>
Similarly, we calculate the best cost for all <b>n-1</b>
sub-trees with two elements, c(g,h), c(h,i), <i>etc</i>.
</p></td></tr>
</tbody></table>
The sub-trees containing two elements are then used to
calculate the best costs for sub-trees of 3 elements.
This process is continued until we have calculated the
cost and the root for the optimal search tree with
<b>n</b> elements.
</p><p>There are <b>O(n<sup>2</sup>)</b> such sub-tree costs.
Each one requires <b>n</b> operations to determine,
if the cost of the smaller sub-trees is known.
</p><p>
Thus the overall algorithm is <b>O(n<sup>3</sup>)</b>.
</p><p>
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/source/optbin.c" target="source">Code for optimal binary
search tree</a><br>
Note some C 'tricks' to handle dynamically-allocated two-dimensional
arrays using pre-processor macros for C and BEST!<br>
This <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/Java/opt_bin/OBSearch.java" target="source">Java code</a> 
may be easier to comprehend for some!
It uses this class for 
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/Java/opt_bin/IntMatrix.java" target="source1">integer matrices</a>.
</p><p>
The data structures used may be represented:
<br>
<img src="./Data Structures and Algorithms_ Optimal Binary Search Tree_files/optbin1.gif">
</p><p>
After the initialisation steps, the data structures used
contain the frequencies, <b>rf<sub>i</sub></b>,
in <b>c<sub>ii</sub></b> (the costs of single element trees),
<b>max</b> everywhere below the diagonal and zeroes in
the positions just above the diagonal (to allow for the
trees which don't have a left or right branch):
<br>
<img src="./Data Structures and Algorithms_ Optimal Binary Search Tree_files/optbin2.gif">
</p><p>
In the first iteration, all the positions below the
diagonal (<b>c<sub>i,i+1</sub></b>) will be filled in
with the optimal costs of two-element trees from
<b>i</b> to <b>i+1</b>.
</p><p>
In subsequent iterations, the optimal costs of <b>k-1</b>
element trees (<b>c<sub>i,i+k</sub></b>) are filled in
using previously calculated costs of smaller trees.

</p><h3>Animation</h3>

<a name="opt_bin_anim">
<table bgcolor="#00f0f0" width="100%"> 
<tbody><tr><td>
<font color="blue" face="helvetica">
<b>Optimal Binary Search Tree Animation</b><br>
This animation was written by John Morris and (mostly) Woi Ang</font></td>
<td align="center">
  <table border="0">
  <tbody><tr><td>
    <applet codebase="Java/opt_bin" code="AlgAnimApp.class" width="200" height="35">
    <param name="filename" value="AlgThread.java">
    <param name="buttonname" value="Run the Animation">
    <param name="algname" value="Optimal Binary Search Tree">
    </applet>
    </td>
  </tr>
</tbody></table>
</td>
<td><font face="helvetica">Please email comments to:<br>
<img src="./Data Structures and Algorithms_ Optimal Binary Search Tree_files/john_email.gif">
</font></td></tr>
</tbody></table>
<p>

<table cellpadding="5" width="100%" bgcolor="#00f0f0" cellspacing="4">
<tbody><tr><td width="50%">
Continue on to <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/mat_chain.html">Matrix Chain Multiplication</a></td>
<td>Back to the <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/ds_ToC.html">Table of Contents</a>
</td></tr></tbody></table>
<small>
Â© <img src="./Data Structures and Algorithms_ Optimal Binary Search Tree_files/john_email.gif">, 1998
</small>



</p></a></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>