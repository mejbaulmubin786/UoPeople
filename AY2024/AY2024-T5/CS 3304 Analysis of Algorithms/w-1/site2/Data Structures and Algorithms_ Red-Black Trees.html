
<!-- saved from url=(0076)https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html#red_black_anim -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Data Structures and Algorithms: Red-Black Trees</title>

<meta name="description" content="Data Structures and Algorithms Course Notes,
PLDS210 University of Western Australia">
<meta name="keywords" content="data structures,algorithms,abstract data types,
red-black trees, binary trees, balanced trees, search trees, dynamic search trees">
</head>
<body bgcolor="#ffffff" data-new-gr-c-s-check-loaded="14.1077.0" data-gr-ext-installed="">
<table bgcolor="#00c0f0" width="100%" cellspacing="0" cellpadding="0">
<tbody><tr bgcolor="#00f0f0"><td align="right">
<font face="helvetica" size="+1"><i>Data Structures and Algorithms</i></font>
</td></tr>

<tr><td><font face="helvetica" size="+2"><b>8.2 Red-Black Trees</b></font>
</td></tr>
</tbody></table>
<p>

A <i>red-black tree</i> is a binary search tree with
one extra attribute for each node: the <i>colour</i>,
which is either red or black.
We also need to keep track of the parent of each node, 
so that a red-black tree's node structure would
be:
<font color="green"></font></p><pre><font color="green">struct t_red_black_node {
    enum { red, black } colour;
    void *item;
    struct t_red_black_node *left,
                     *right,
                     *parent;
    }
</font></pre>

For the purpose of this discussion,
the NULL nodes which terminate the tree are considered to
be the leaves and are coloured black.

<h4>Definition of a red-black tree</h4>

A red-black tree is a binary search tree which has the
following <i>red-black properties</i>:
<table>
<tbody><tr><td width="60%">
<ol>
<li> Every node is either red or black.
</li><li> Every leaf (NULL) is black.
</li><li> If a node is red, then both its children are black.
</li><li> Every simple path from a node to a descendant leaf
contains the same number of black nodes.
</li></ol>
</td>
<td><small>
<ol>
<li value="3"> implies that on any path from the
root to a leaf, red nodes must not be adjacent.
<br>
However, any number of black nodes may appear in a sequence.

</li></ol></small></td></tr>
</tbody></table>
<table>
<tbody><tr>
<td><img src="./Data Structures and Algorithms_ Red-Black Trees_files/rb_tree1.gif"></td><td>A basic red-black tree</td>
</tr>
<tr>
<td><img src="./Data Structures and Algorithms_ Red-Black Trees_files/rb_tree1a.gif"></td><td>Basic red-black tree with the
<b>sentinel</b> nodes added.
Implementations of the red-black tree algorithms will usually include
the sentinel nodes as a convenient means of flagging that you have
reached a leaf node.<p>
They are the NULL black nodes of property 2.</p></td>
</tr>
</tbody></table>
The number of black nodes on any path from,
but not including, a node <b><i>x</i></b> to a leaf is
called the <i>black-height</i> of a node,
denoted <b>bh(x)</b>.

We can prove the following lemma:
<h5>Lemma</h5>
A red-black tree with <b><i>n</i></b> internal nodes has
height at most 2<b>log(<i>n</i>+1)</b>.
<br>
<i>(For a proof, see Cormen, p 264)</i>
<p>
This demonstrates why the red-black tree is a good
search tree: it can always be searched in <b>O(log n)</b> time.

</p><p>
As with heaps, additions and deletions from red-black
trees destroy the red-black property, so we need to restore it.
To do this we need to look at some operations on
red-black trees.
</p><h4>Rotations</h4>
<center><table>
<tbody><tr><td>
A rotation is a local operation
in a search tree that preserves 
<i>in-order</i> traversal key ordering.
<p>
Note that in both trees, an in-order
traversal yields:</p><p>
</p><center><pre>A x B y C</pre></center>
</td><td><img src="./Data Structures and Algorithms_ Red-Black Trees_files/rb_tree_rot.gif"></td></tr>
</tbody></table></center>
The left_rotate operation may be encoded:
<font color="green"><pre>left_rotate( Tree T, node x ) {
    node y;
    y = x-&gt;right;
    /* Turn y's left sub-tree into x's right sub-tree */
    x-&gt;right = y-&gt;left;
    if ( y-&gt;left != NULL )
        y-&gt;left-&gt;parent = x;
    /* y's new parent was x's parent */
    y-&gt;parent = x-&gt;parent;
    /* Set the parent to point to y instead of x */
    /* First see whether we're at the root */
    if ( x-&gt;parent == NULL ) T-&gt;root = y;
    else
        if ( x == (x-&gt;parent)-&gt;left )
            /* x was on the left of its parent */
            x-&gt;parent-&gt;left = y;
        else
            /* x must have been on the right */
            x-&gt;parent-&gt;right = y;
    /* Finally, put x on y's left */
    y-&gt;left = x;
    x-&gt;parent = y;
    }
</pre></font>

<h4>Insertion</h4>

Insertion is somewhat complex and involves a number
of cases.
Note that we start by inserting the new node, <tt>x</tt>,
in the tree just as we would for any other binary tree,
using the <tt>tree_insert</tt> function.
This new node is labelled red, and possibly
destroys the red-black property.
The main loop moves up the tree,
restoring the red-black property.

<font color="green"><pre>rb_insert( Tree T, node x ) {
    /* Insert in the tree in the usual way */
    tree_insert( T, x );
    /* Now restore the red-black property */
    x-&gt;colour = red;
    while ( (x != T-&gt;root) &amp;&amp; (x-&gt;parent-&gt;colour == red) ) {
       if ( x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left ) {
           /* If x's parent is a left, y is x's right 'uncle' */
           y = x-&gt;parent-&gt;parent-&gt;right;
           if ( y-&gt;colour == red ) {
               /* case 1 - change the colours */
               x-&gt;parent-&gt;colour = black;
               y-&gt;colour = black;
               x-&gt;parent-&gt;parent-&gt;colour = red;
               /* Move x up the tree */
               x = x-&gt;parent-&gt;parent;
               }
           else {
               /* y is a black node */
               if ( x == x-&gt;parent-&gt;right ) {
                   /* and x is to the right */ 
                   /* case 2 - move x up and rotate */
                   x = x-&gt;parent;
                   left_rotate( T, x );
                   }
               /* case 3 */
               x-&gt;parent-&gt;colour = black;
               x-&gt;parent-&gt;parent-&gt;colour = red;
               right_rotate( T, x-&gt;parent-&gt;parent );
               }
           }
       else {
           /* repeat the "if" part with right and left
              exchanged */
           }
       }
    /* Colour the root black */
    T-&gt;root-&gt;colour = black;
    }
       
</pre></font>
<p>
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html" target="op">Here's an example of the insertion operation</a>.
</p><p>

</p><h3>Animation</h3>

<a name="red_black_anim">
<table bgcolor="#00f0f0" width="100%"> 
<tbody><tr><td>
<font color="blue" face="helvetica">
<b>Red-Black Tree Animation</b><br>
This animation was written by Linda Luo, 
Mervyn Ng, Anita Lee, John Morris and Woi Ang.</font></td>
<td align="center">
  <table border="0">
  <tbody><tr><td>
    <applet codebase="Java/red_black" code="ciips.animation.AlgAnimApp.class" width="200" height="35">
    <param name="filename" value="AlgThread.java">
    <param name="algfile" value="rb">
    <param name="buttonname" value="Run Red-Black Tree Animation">
    <param name="algname" value="RBTree">
    </applet>
    </td>
  </tr>
</tbody></table>
</td>
<td><font face="helvetica">Please email comments to:<br>
<img src="./Data Structures and Algorithms_ Red-Black Trees_files/john_email.gif">
</font></td></tr>
</tbody></table>

<p>
Examination of the code reveals only one
loop. 
In that loop, the node at the root of the sub-tree
whose red-black property we are trying to restore, <tt>x</tt>,
may be moved up the tree <i>at least one level</i> in each iteration
of the loop.
Since the tree originally has <b>O(log n)</b> height,
there are <b>O(log n)</b> iterations. 
The 
<font color="green"><tt>tree_insert</tt></font>
routine also has <b>O(log n)</b> complexity,
so overall the 
<font color="green"><tt>rb_insert</tt></font>
routine also has <b>O(log n)</b> complexity.
</p><p>

</p><p>
<table width="100%" bgcolor="#00c0f0">
<tbody><tr><td><h3>Key terms</h3></td></tr></tbody></table>
</p><dl>
<dt><font color="#fa0000"><b>Red-black trees</b></font>
   </dt><dd>Trees which remain <b>balanced</b> - and thus guarantee
 <b>O(logn)</b> search times - in a dynamic environment.
 Or more importantly, since any tree can be re-balanced - but at
 considerable cost - can be re-balanced in <b>O(logn)</b> time.
</dd></dl>

<p>

<table cellpadding="5" width="100%" bgcolor="#00f0f0" cellspacing="4">
<tbody><tr><td width="50%">
Continue on to <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/AVL.html">AVL Trees</a></td>
<td>Back to the <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/ds_ToC.html">Table of Contents</a>
</td></tr></tbody></table>
<small>
Â© <img src="./Data Structures and Algorithms_ Red-Black Trees_files/john_email.gif">, 1998
</small>


</p></a></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>