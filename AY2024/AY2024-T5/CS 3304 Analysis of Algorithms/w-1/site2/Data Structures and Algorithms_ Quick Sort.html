
<!-- saved from url=(0068)https://www.cs.auckland.ac.nz/software/AlgAnim/qsort.html#qsort_anim -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Data Structures and Algorithms: Quick Sort</title>

<meta name="description" content="Data Structures and Algorithms Course Notes,
PLDS210 University of Western Australia">
<meta name="keywords" content="data structures,algorithms,abstract data types,
sorting, quick sort, QuickSort">
</head>
<body bgcolor="#ffffff" data-new-gr-c-s-check-loaded="14.1077.0" data-gr-ext-installed="">
<table bgcolor="#00c0f0" width="100%" cellspacing="0" cellpadding="0">
<tbody><tr bgcolor="#00f0f0"><td align="right">
<font face="helvetica" size="+1"><i>Data Structures and Algorithms</i></font>
</td></tr>

<tr><td><font face="helvetica" size="+2"><b>7.3 Quick Sort</b></font>
</td></tr>
</tbody></table>
<p>

Quicksort is a very efficient sorting algorithm invented by C.A.R. Hoare.
It has two phases:
 </p><ul>
 <li>the partition phase and
 </li><li>the sort phase.
 </li></ul>
As we will see, most of the work is done in the partition phase - 
it works out where to divide the work.
The sort phase simply sorts the two smaller 
problems that are generated in the partition phase.
<p>
This makes Quicksort a good example of the 
<font color="#fa0000"><b>divide and conquer</b></font>
strategy for solving problems.
(You've already seen an example of this approach in the
<a href="https://www.cs.auckland.ac.nz/software/AlgAnim/searching.html#binary-search">binary search procedure</a>.)
In quicksort, we divide the array of items to be sorted into
two partitions and then call the quicksort procedure recursively
to sort the two partitions,
<i>ie</i> we <i>divide</i> the problem into two smaller ones and
<i>conquer</i> by solving the smaller ones.
Thus the conquer part of the quicksort routine looks like this:

<table border="">
<tbody><tr>
<td rowspan="2"><font color="green"><pre>quicksort( void *a, int low, int high )
  {
  int pivot;
  /* Termination condition! */
  if ( high &gt; low )
    {
    pivot = partition( a, low, high );
    quicksort( a, low, pivot-1 );
    quicksort( a, pivot+1, high );
    }
  }
</pre></font>
</td>
<td><center><img src="./Data Structures and Algorithms_ Quick Sort_files/qsort_divide.gif"><br>
Initial Step - First Partition</center></td></tr>
<tr><td align="CENTER"><img src="./Data Structures and Algorithms_ Quick Sort_files/qsort_div2.gif"><br>
Sort Left Partition in the same way</td> </tr>
</tbody></table>

For the strategy to be effective, the <i>partition</i> phase
must ensure that all the items in one part (the lower part) and less than
all those in the other (upper) part.
</p><p>
To do this, we choose a <i>pivot</i> element and arrange that all the
 items in the lower part are less than the pivot and all those in the
 upper part greater than it.
 In the most general case, we don't know anything about the items to be
 sorted, so that any choice of the pivot element will do -
 the first element is a convenient one.
</p><p>
As an illustration of this idea,
you can view this animation,
which shows a partition algorithm in which items to be sorted
are copied from the original array to a new one:
items <i>smaller</i> than the pivot are placed to the left
of the new array and items <i>greater</i> than the pivot
are placed on the right. In the final step, the
pivot is dropped into the remaining slot in the middle. 

<a name="qsort_anim">
<table bgcolor="#00f0f0" width="100%"> 
<tbody><tr><td>
<font color="blue" face="helvetica">
<b>QuickSort Animation</b><br>
This animation was based on a suggestion
made by Jeff Rohl;<br>
it was written by Woi Ang.</font></td>
<td align="center">
<applet codebase="Java/quick_sort" code="AlgAnimApp.class" width="200" height="35">
<param name="filename" value="AlgThread.java">
<param name="buttonname" value="Run Quick Sort Animation">
<param name="algname" value="Quick Sort">
</applet>
<p>
</p></td>
</tr></tbody></table>
Observe that the animation uses two arrays for the items being
sorted:
thus it requires <b><i>O(n)</i></b> additional <b>space</b>
to operate.
However, it's possible to partition the array
<font color="#fa0000"><b>in place</b></font>.
The next page shows a conventional implementation of the
partition phase which swaps elements in the same array
and thus avoids using extra space.

</a></p><p><a name="qsort_anim">
<table width="100%" bgcolor="#00c0f0">
<tbody><tr><td><h3>Key terms</h3></td></tr></tbody></table>
</a></p><dl><a name="qsort_anim">
<dt><font color="#fa0000"><b>Divide and Conquer Algorithms</b></font>
   </dt><dd>Algorithms that solve (conquer) problems by dividing them into
      smaller sub-problems until the problem is so small that it is
      trivially solved.
</dd><dt><font color="#fa0000"><b>in place</b></font>
	</dt><dd>In place sorting algorithms don't require additional temporary
       space to store elements as they sort;
      they use the space originally occupied by the elements.
</dd></a></dl><a name="qsort_anim">

<p>

<table cellpadding="5" width="100%" bgcolor="#00f0f0" cellspacing="4">
<tbody><tr><td width="50%">
Continue on to <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/qsort1a.html">Quick sort: Partition in place</a></td>
<td>Back to the <a href="https://www.cs.auckland.ac.nz/software/AlgAnim/ds_ToC.html">Table of Contents</a>
</td></tr></tbody></table>
<small>
Â© <img src="./Data Structures and Algorithms_ Quick Sort_files/john_email.gif">, 1998
</small>




</p></a></body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>